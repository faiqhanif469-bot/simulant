"""\nSimulant Backend API\nProfessional AI-powered website testing\n"""\nfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, validator\nfrom typing import List, Optional\nimport asyncio\nfrom datetime import datetime\n\nfrom database import init_db, async_session\nfrom database.models import Test, TestResult\nfrom agents.manager import AgentManager\n\napp = FastAPI(\n    title="Simulant API",\n    version="1.0.0",\n    description="Professional AI-powered website testing"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["http://localhost:3000", "https://*.vercel.app"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\nactive_connections: dict = {}\nagent_manager = AgentManager()\n\n\n@app.on_event("startup")\nasync def startup():\n    await init_db()\n\n\n# --- Request/Response Models ---\nclass TestRequest(BaseModel):\n    url: str\n    personas: List[str]\n    user_id: str = "anonymous"\n    \n    @validator('url')\n    def validate_url(cls, v):\n        if not v:\n            raise ValueError('URL is required')\n        if not v.startswith(('http://', 'https://')):\n            raise ValueError('URL must start with http:// or https://')\n        if len(v) > 2000:\n            raise ValueError('URL too long')\n        return v.strip()\n    \n    @validator('personas')\n    def validate_personas(cls, v):\n        valid = {'jake', 'grandma', 'alex', 'priya', 'marcus'}\n        invalid = [p for p in v if p not in valid]\n        if invalid:\n            raise ValueError(f'Invalid personas: {invalid}')\n        if not v:\n            raise ValueError('Select at least one agent')\n        if len(v) > 5:\n            raise ValueError('Maximum 5 agents')\n        return v\n\n\nclass TestResponse(BaseModel):\n    test_id: int\n    status: str\n    message: str = ""\n\n\nclass ErrorResponse(BaseModel):\n    detail: str\n\n\n# --- Endpoints ---\n@app.get("/")\nasync def root():\n    return {\n        "name": "Simulant API",\n        "version": "1.0.0",\n        "status": "running",\n        "docs": "/docs"\n    }\n\n\n@app.get("/health")\nasync def health():\n    return {"status": "healthy", "timestamp": datetime.utcnow().isoformat()}\n\n\n@app.get("/agents")\nasync def get_agents():\n    """Get available testing agents"""\n    return {\n        "agents": [\n            {"id": "jake", "name": "Jake", "role": "Performance Analyst", "focus": "Speed, load times"},\n            {"id": "grandma", "name": "Rose", "role": "Accessibility Analyst", "focus": "Usability, a11y"},\n            {"id": "alex", "name": "Alex", "role": "Security Analyst", "focus": "Vulnerabilities"},\n            {"id": "priya", "name": "Priya", "role": "QA Analyst", "focus": "Functionality, bugs"},\n            {"id": "marcus", "name": "Marcus", "role": "Mobile Analyst", "focus": "Responsive, mobile UX"},\n        ]\n    }\n\n\n@app.post("/test/start", response_model=TestResponse, responses={400: {"model": ErrorResponse}})\nasync def start_test(request: TestRequest):\n    """Start a new test"""\n    try:\n        async with async_session() as db:\n            test = Test(\n                user_id=request.user_id[:100] if request.user_id else "anonymous",\n                url=request.url,\n                personas=request.personas,\n                status="pending"\n            )\n            db.add(test)\n            await db.commit()\n            await db.refresh(test)\n            \n            asyncio.create_task(\n                agent_manager.run_test(test.id, request.url, request.personas)\n            )\n            \n            return TestResponse(\n                test_id=test.id,\n                status="started",\n                message=f"Test started with {len(request.personas)} agent(s)"\n            )\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Failed to start test: {str(e)[:100]}")\n\n\n@app.post("/test/{test_id}/cancel")\nasync def cancel_test(test_id: int):\n    """Cancel a running test - generates report for completed work"""\n    async with async_session() as db:\n        from sqlalchemy import select\n        result = await db.execute(select(Test).where(Test.id == test_id))\n        test = result.scalar_one_or_none()\n        \n        if not test:\n            raise HTTPException(status_code=404, detail="Test not found")\n        \n        if test.status in ["completed", "cancelled", "failed"]:\n            return {"status": test.status, "message": "Test already finished"}\n    \n    cancelled = await agent_manager.cancel_test(test_id)\n    if cancelled:\n        return {"status": "cancelling", "message": "Test is being cancelled. Reports will be generated for completed work."}\n    \n    return {"status": "completed", "message": "Test already finished or not running"}\n\n\n@app.get("/test/{test_id}")\nasync def get_test(test_id: int):\n    """Get test results"""\n    async with async_session() as db:\n        from sqlalchemy import select\n        \n        result = await db.execute(select(Test).where(Test.id == test_id))\n        test = result.scalar_one_or_none()\n        \n        if not test:\n            raise HTTPException(status_code=404, detail="Test not found")\n        \n        results_query = await db.execute(\n            select(TestResult).where(TestResult.test_id == test_id)\n        )\n        results = results_query.scalars().all()\n        \n        all_bugs = []\n        for r in results:\n            all_bugs.extend(r.bugs_found or [])\n        \n        return {\n            "id": test.id,\n            "url": test.url,\n            "status": test.status,\n            "personas": test.personas,\n            "created_at": test.created_at.isoformat(),\n            "summary": {\n                "total_bugs": len(all_bugs),\n                "critical": len([b for b in all_bugs if b.get("severity") == "critical"]),\n                "high": len([b for b in all_bugs if b.get("severity") == "high"]),\n                "medium": len([b for b in all_bugs if b.get("severity") == "medium"]),\n                "low": len([b for b in all_bugs if b.get("severity") == "low"]),\n                "avg_score": round(sum(r.quality_score or 0 for r in results) / max(len(results), 1), 1)\n            },\n            "results": [\n                {\n                    "persona": r.persona,\n                    "status": r.status,\n                    "bugs_found": r.bugs_found or [],\n                    "quality_score": r.quality_score,\n                    "summary": r.summary\n                }\n                for r in results\n            ]\n        }\n\n\n@app.get("/test/{test_id}/bugs")\nasync def get_bugs(test_id: int, severity: Optional[str] = None):\n    """Get all bugs from a test"""\n    async with async_session() as db:\n        from sqlalchemy import select\n        \n        results = await db.execute(\n            select(TestResult).where(TestResult.test_id == test_id)\n        )\n        \n        bugs = []\n        for r in results.scalars():\n            for bug in (r.bugs_found or []):\n                bug["found_by"] = r.persona\n                if severity is None or bug.get("severity") == severity:\n                    bugs.append(bug)\n        \n        order = {"critical": 0, "high": 1, "medium": 2, "low": 3}\n        bugs.sort(key=lambda b: order.get(b.get("severity", "low"), 4))\n        \n        return {"test_id": test_id, "total": len(bugs), "bugs": bugs}\n\n\n@app.get("/tests")\nasync def get_tests(user_id: str = "anonymous", limit: int = 20):\n    """Get test history"""\n    async with async_session() as db:\n        from sqlalchemy import select\n        \n        result = await db.execute(\n            select(Test)\n            .where(Test.user_id == user_id)\n            .order_by(Test.created_at.desc())\n            .limit(min(limit, 100))\n        )\n        \n        return {\n            "tests": [\n                {\n                    "id": t.id,\n                    "url": t.url,\n                    "status": t.status,\n                    "personas": t.personas,\n                    "created_at": t.created_at.isoformat()\n                }\n                for t in result.scalars()\n            ]\n        }\n\n\n# --- WebSocket ---\n@app.websocket("/ws/{test_id}")\nasync def websocket_endpoint(websocket: WebSocket, test_id: int):\n    await websocket.accept()\n    active_connections[test_id] = websocket\n    \n    await websocket.send_json({"type": "connected", "test_id": test_id})\n    \n    try:\n        while True:\n            try:\n                data = await asyncio.wait_for(websocket.receive_text(), timeout=30)\n                if data == "ping":\n                    await websocket.send_json({"type": "pong"})\n            except asyncio.TimeoutError:\n                await websocket.send_json({"type": "keepalive"})\n    except WebSocketDisconnect:\n        pass\n    finally:\n        active_connections.pop(test_id, None)\n\n\nasync def broadcast_update(test_id: int, data: dict):\n    """Send update to client"""\n    ws = active_connections.get(test_id)\n    if ws:\n        try:\n            await ws.send_json(data)\n        except:\n            active_connections.pop(test_id, None)\n\n\nagent_manager.broadcast = broadcast_update\n\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8000)\n